//+===================================================================
// File Lab4.cpp
// Распаковка битовых групп
//
// Эта программа распаковывает битовые группы из целого беззнакового числа
//
// (C) Жданов В.И., 2012
//
// Входные данные:
// Длинное целое число, которое содержит несколько битовых групп
//
// 31----+-----+-----+-----+-----0
// ! mod ! kop ! w_b ! reg1! reg2!	value
// +-----+-----+-----+-----+-----+
//	  7	   12	  2	    7	  4
//
// Выходные данные:
// 7----3------0
// ! 00 ! reg2 ! reg2
// +----+------+
//		   4
// 7---6------0
// ! 0 ! reg1 ! reg1
// +---+------+
//		   7
// 7----1-----0
// ! 00 ! w_b ! w_b
// +----+-----+
//	       2
// 15---11------0
// ! 00 ! kop ! kop
// +----+------+
//		  12
// 7---6------0
// ! 0 ! mod ! mod
// +---+------+
//		   7

//-===================================================================
#include <iostream>
#include <iomanip>
using namespace std;
unsigned long value;
unsigned char xxx, www, xxx_a, www_a;
unsigned short yyy, zzz, yyy_a, zzz_a;
unsigned char reg2, reg1, w_b, mod, reg2_a, reg1_a, w_b_a, mod_a;
unsigned short kop, kop_a;
int main()
{
	setlocale(LC_ALL, "Russian");
	printf("\n\t\t(C)Жданов В.И., 2012");
	printf("\n\tРаспаковка битовых групп");
	for (;;)
	{
		printf("\n\tРаспаковать 32-битовое число Value");
		printf("\nПожалуйста, введите 8 16-ых цифр (например, 5a9db8e4) : ");
		scanf_s("%x", &value);
		//=============================== C ==================================
		// Выделить битовые группы из числа Value
		reg2 = value & 0xf; // выделить 4 младших бита(3-0) из Value
		reg1 = (value >> 4) & 0x7f;// выделить 7 битов (10-4) из Value
		w_b = (value >> 11) & 0x3;// выделить 2 бита (12-11) из Value
		kop = (value >> 13) & 0xfff;// выделить 12 битов (24-13) из Value
		mod = (value >> 25) & 0x3f;// выделить 7 битов (31-25) из Value
		//============================ Assembler =============================
		// Выделить битоые группы из числа Value
		__asm {
			mov eax, value
			// выделить 4 младших бита(3-0) из Value
			mov reg2_a, al
			and reg2_a, 0xf
			shr eax, 4
			// выделить 7 битов (10-4) из Value
			mov reg1_a, al
			and reg1_a, 0x7f
			shr eax, 7
			// выделить 2 бита (12-11) из Value
			mov w_b_a, al
			and w_b_a, 0x3
			shr eax, 2
			// выделить 12 битов (24-13) из Value
			mov kop_a, ax
			and kop_a, 0xfff
			shr eax, 12
			// выделить 7 битов (31-25) из Value
			mov mod_a, al
			and mod_a, 0x3f
		};
		// Форматный вывод результатов
		cout << hex
			<< "Битовая группа mod (C++): " << (int)mod
			<< "\nБитовая группа kop (C++): " << (int)kop
			<< "\nБитовая группа w_b (C++): " << (int)w_b
			<< "\nБитовая группа reg1(C++): " << (int)reg1
			<< "\nБитовая группа reg2(C++): " << (int)reg2
			<< "\nБитовая группа mod (Asm): " << (int)mod_a
			<< "\nБитовая группа kop (Asm): " << (int)kop_a
			<< "\nБитовая группа w_b (Asm): " << (int)w_b_a
			<< "\nБитовая группа reg1(Asm): " << (int)reg1_a
			<< "\nБитовая группа reg2(Asm): " << (int)reg2_a
			<< endl;
	};
	return 0;
}
